/**
 * Import YearTop data from processed JSON files into the database.
 *
 * This script reads JSON files generated by parse-year-top-csv.ts and creates
 * YearTopParticipant, YearTopPick, and Movie records.
 *
 * Usage:
 *   npx tsx scripts/import-year-top-json.ts --json "data/year-top-2022-processed.json" --year 2022
 *   npx tsx scripts/import-year-top-json.ts --json "data/year-top-2022-processed.json" --year 2022 --dry-run
 *   npx tsx scripts/import-year-top-json.ts --json "data/year-top-2022-processed.json" --year 2022 --mapping=./user-mapping.json
 */

import { PrismaClient, YearTopPickType } from '../generated/prisma/client';
import { PrismaPg } from '@prisma/adapter-pg';
import { Pool } from 'pg';
import * as fs from 'fs';
import * as path from 'path';
import * as process from 'process';
import 'dotenv/config';

interface MoviePick {
  position: number;
  movieName: string;
  tmdbId: number | null;
  tmdbTitle: string | null;
  imdbId: string | null;
  releaseDate: string | null;
  posterUrl?: string | null;
  originalLanguage?: string | null;
  originalTitle?: string | null;
  error?: string;
}

interface ParticipantData {
  name: string;
  topPicks: MoviePick[];
  worstPicks: MoviePick[];
}

interface ProcessedData {
  year: number;
  participants: ParticipantData[];
  unmatchedMovies: Array<{
    movieName: string;
    participants: string[];
    tmdbResults: Array<{
      id: number;
      title: string;
      release_date: string;
    }>;
  }>;
  ambiguousMatches: Array<{
    movieName: string;
    participants: string[];
    tmdbResults: Array<{
      id: number;
      title: string;
      release_date: string;
    }>;
  }>;
}

interface UserMapping {
  [participantName: string]: string; // participant name -> user ID
}

// Participant name mappings: CSV name -> DB displayName
const PARTICIPANT_NAME_MAPPINGS: Record<string, string> = {
  '@clauhernan73': 'claudiohernan73',
  clauhernan73: 'claudiohernan73',
  '@MatiasGilRobert': '110x75',
  MatiasGilRobert: '110x75',
  'Alan Gabriel': 'alangmonzon',
  'Biam!': 'ponybiam',
};

function parseArgs(argv: string[]) {
  let jsonPath: string | undefined = undefined;
  let year: number | undefined = undefined;
  let dryRun = false;
  let help = false;
  let mappingPath: string | undefined = undefined;

  for (let i = 0; i < argv.length; i++) {
    const arg = argv[i];

    if (arg === '--help' || arg === '-h') {
      help = true;
      continue;
    }

    if (arg === '--dry-run') {
      dryRun = true;
      continue;
    }

    if (arg === '--json') {
      const next = argv[i + 1];
      if (!next) throw new Error('Missing value for --json');
      jsonPath = next;
      i++;
      continue;
    }

    if (arg.startsWith('--json=')) {
      jsonPath = arg.slice('--json='.length);
      continue;
    }

    if (arg === '--year') {
      const next = argv[i + 1];
      if (!next) throw new Error('Missing value for --year');
      year = parseInt(next, 10);
      if (isNaN(year)) throw new Error(`Invalid year: ${next}`);
      i++;
      continue;
    }

    if (arg.startsWith('--year=')) {
      year = parseInt(arg.slice('--year='.length), 10);
      if (isNaN(year)) throw new Error(`Invalid year: ${arg.slice('--year='.length)}`);
      continue;
    }

    if (arg.startsWith('--mapping=')) {
      mappingPath = arg.slice('--mapping='.length);
      continue;
    }
  }

  return { jsonPath, year, dryRun, help, mappingPath };
}

function printHelp() {
  console.log(`
Usage: npx tsx scripts/import-year-top-json.ts [options]

Options:
  --json <path>       Path to processed JSON file (required)
  --year <year>       Year for the data (required)
  --mapping <path>    Path to user mapping JSON file (optional)
  --dry-run           Run without making database changes
  --help, -h          Show this help message

Example:
  npx tsx scripts/import-year-top-json.ts --json data/year-top-2022-processed.json --year 2022
  npx tsx scripts/import-year-top-json.ts --json data/year-top-2022-processed.json --year 2022 --dry-run
  npx tsx scripts/import-year-top-json.ts --json data/year-top-2022-processed.json --year 2022 --mapping=./user-mapping.json
`);
}

function stripLeadingAt(text: string): string {
  return text.replace(/^@+/, '').trim();
}

function generateSlug(displayName: string): string {
  return displayName
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .substring(0, 50);
}

async function main() {
  const args = parseArgs(process.argv.slice(2));

  if (args.help) {
    printHelp();
    return;
  }

  if (!args.jsonPath) {
    throw new Error('--json is required');
  }

  if (!args.year) {
    throw new Error('--year is required');
  }

  const connectionString = process.env.DATABASE_URL;
  if (!connectionString) {
    throw new Error('DATABASE_URL environment variable is not set');
  }

  const pool = new Pool({ connectionString });
  const adapter = new PrismaPg(pool);
  const prisma = new PrismaClient({ adapter });

  console.log('üé¨ YearTop JSON Import Script');
  console.log('============================');
  console.log(`Year: ${args.year}`);
  if (args.dryRun) console.log('üîç DRY RUN MODE - No changes will be made\n');

  // Load user mapping if provided
  let userMapping: UserMapping = {};
  if (args.mappingPath) {
    try {
      const mappingContent = fs.readFileSync(args.mappingPath, 'utf8');
      userMapping = JSON.parse(mappingContent);
      console.log(`‚úÖ Loaded user mapping with ${Object.keys(userMapping).length} entries\n`);
    } catch (error) {
      console.error(`‚ùå Failed to load user mapping from ${args.mappingPath}:`, error);
      process.exit(1);
    }
  }

  // Read JSON
  const jsonPath = path.resolve(args.jsonPath);
  if (!fs.existsSync(jsonPath)) {
    throw new Error(`JSON file not found: ${jsonPath}`);
  }

  console.log(`üìÑ Reading JSON: ${jsonPath}`);
  const jsonContent = fs.readFileSync(jsonPath, 'utf8');
  const processedData: ProcessedData = JSON.parse(jsonContent);

  // Validate year matches
  if (processedData.year !== args.year) {
    throw new Error(
      `Year mismatch: JSON file has year ${processedData.year}, but --year is ${args.year}`
    );
  }

  console.log(`‚úÖ Parsed ${processedData.participants.length} participants\n`);

  // Statistics
  let participantsCreated = 0;
  let participantsUpdated = 0;
  let picksCreated = 0;
  let picksSkipped = 0;
  let moviesCreated = 0;
  let moviesSkipped = 0;
  const errors: Array<{
    participant: string;
    pickType: string;
    movieName: string;
    error: string;
  }> = [];

  // Process each participant
  for (const participantData of processedData.participants) {
    // Normalize participant name
    let displayName = participantData.name;
    displayName = PARTICIPANT_NAME_MAPPINGS[displayName] ?? displayName;
    displayName = stripLeadingAt(displayName);
    const slug = generateSlug(displayName);

    // Get or create participant
    let participant = await prisma.yearTopParticipant.findUnique({
      where: {
        year_slug: {
          year: args.year,
          slug,
        },
      },
    });

    // Try to determine userId:
    // 1) Explicit mapping file (highest priority)
    // 2) Reuse userId from existing MamParticipant with same slug
    let userId: string | null =
      userMapping[displayName] ?? userMapping[participantData.name] ?? null;

    if (!userId) {
      const existingMamParticipant = await prisma.mamParticipant.findUnique({
        where: { slug },
        select: { userId: true },
      });
      if (existingMamParticipant?.userId) {
        userId = existingMamParticipant.userId;
      }
    }

    if (!participant) {
      if (!args.dryRun) {
        participant = await prisma.yearTopParticipant.create({
          data: {
            year: args.year,
            displayName,
            slug,
            userId: userId ?? undefined,
          },
        });
        participantsCreated++;
      } else {
        participantsCreated++;
        console.log(`  Would create participant: ${displayName} (${slug})`);
      }
    } else {
      // Update userId if we have a mapping
      if (userId && participant.userId !== userId) {
        if (!args.dryRun) {
          await prisma.yearTopParticipant.update({
            where: { id: participant.id },
            data: { userId },
          });
          participantsUpdated++;
        } else {
          participantsUpdated++;
          console.log(`  Would update participant: ${displayName} (userId: ${userId})`);
        }
      }
    }

    if (args.dryRun && !participant) {
      // Create a mock participant for dry run
      participant = {
        id: -1,
        year: args.year,
        displayName,
        slug,
        userId: userId ?? null,
        createdAt: new Date(),
      } as any;
    }

    // Process top picks
    for (const pick of participantData.topPicks) {
      // Skip if no TMDB data (require at least tmdbId)
      if (!pick.tmdbId) {
        errors.push({
          participant: displayName,
          pickType: 'TOP_10',
          movieName: pick.movieName,
          error: pick.error || 'Missing TMDB data',
        });
        continue;
      }

      // Skip if no IMDb ID (required for database)
      if (!pick.imdbId) {
        errors.push({
          participant: displayName,
          pickType: 'TOP_10',
          movieName: pick.movieName,
          error: 'Missing IMDb ID',
        });
        continue;
      }

      // Get or create movie
      let movie = await prisma.movie.findUnique({
        where: { imdbId: pick.imdbId },
      });

      if (!movie) {
        // Use data from JSON if available, otherwise fetch from TMDB
        const posterUrl = pick.posterUrl || '';
        const originalLanguage = pick.originalLanguage || 'en';
        const originalTitle = pick.originalTitle || pick.tmdbTitle || pick.movieName;

        if (!args.dryRun) {
          try {
            movie = await prisma.movie.create({
              data: {
                title: pick.tmdbTitle || pick.movieName,
                originalTitle,
                originalLanguage,
                releaseDate: pick.releaseDate ? new Date(pick.releaseDate) : new Date('1900-01-01'),
                letterboxdUrl: '',
                imdbId: pick.imdbId,
                posterUrl,
              },
            });
            moviesCreated++;
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            console.error(`  Error creating movie ${pick.imdbId}: ${errorMessage}`);
            errors.push({
              participant: displayName,
              pickType: 'TOP_10',
              movieName: pick.movieName,
              error: `Failed to create movie: ${errorMessage}`,
            });
            continue;
          }
        } else {
          moviesCreated++;
          console.log(`  Would create movie: ${pick.tmdbTitle || pick.movieName} (${pick.imdbId})`);
        }
      } else {
        moviesSkipped++;
      }

      if (args.dryRun && !movie) {
        movie = { id: -1 } as any;
      }

      // Create pick
      // Position 1 is the highest rank (isTopPosition: true)
      const isTopPosition = pick.position === 1;

      if (!args.dryRun && participant && movie) {
        try {
          await prisma.yearTopPick.upsert({
            where: {
              participantId_movieId_year_pickType: {
                participantId: participant.id,
                movieId: movie.id,
                year: args.year,
                pickType: YearTopPickType.TOP_10,
              },
            },
            create: {
              participantId: participant.id,
              movieId: movie.id,
              year: args.year,
              pickType: YearTopPickType.TOP_10,
              isTopPosition,
            },
            update: {
              isTopPosition,
            },
          });
          picksCreated++;
        } catch (error) {
          picksSkipped++;
          const errorMessage = error instanceof Error ? error.message : String(error);
          errors.push({
            participant: displayName,
            pickType: 'TOP_10',
            movieName: pick.movieName,
            error: `Failed to create pick: ${errorMessage}`,
          });
        }
      } else if (args.dryRun) {
        picksCreated++;
        console.log(
          `  Would create TOP_10 pick: ${pick.movieName} (position ${pick.position}, isTopPosition: ${isTopPosition})`
        );
      }
    }

    // Process worst picks
    for (const pick of participantData.worstPicks) {
      // Skip if no TMDB data (require at least tmdbId)
      if (!pick.tmdbId) {
        errors.push({
          participant: displayName,
          pickType: 'WORST_3',
          movieName: pick.movieName,
          error: pick.error || 'Missing TMDB data',
        });
        continue;
      }

      // Skip if no IMDb ID (required for database)
      if (!pick.imdbId) {
        errors.push({
          participant: displayName,
          pickType: 'WORST_3',
          movieName: pick.movieName,
          error: 'Missing IMDb ID',
        });
        continue;
      }

      // Get or create movie
      let movie = await prisma.movie.findUnique({
        where: { imdbId: pick.imdbId },
      });

      if (!movie) {
        // Use data from JSON if available, otherwise fetch from TMDB
        const posterUrl = pick.posterUrl || '';
        const originalLanguage = pick.originalLanguage || 'en';
        const originalTitle = pick.originalTitle || pick.tmdbTitle || pick.movieName;

        if (!args.dryRun) {
          try {
            movie = await prisma.movie.create({
              data: {
                title: pick.tmdbTitle || pick.movieName,
                originalTitle,
                originalLanguage,
                releaseDate: pick.releaseDate ? new Date(pick.releaseDate) : new Date('1900-01-01'),
                letterboxdUrl: '',
                imdbId: pick.imdbId,
                posterUrl,
              },
            });
            moviesCreated++;
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            console.error(`  Error creating movie ${pick.imdbId}: ${errorMessage}`);
            errors.push({
              participant: displayName,
              pickType: 'WORST_3',
              movieName: pick.movieName,
              error: `Failed to create movie: ${errorMessage}`,
            });
            continue;
          }
        } else {
          moviesCreated++;
          console.log(`  Would create movie: ${pick.tmdbTitle || pick.movieName} (${pick.imdbId})`);
        }
      } else {
        moviesSkipped++;
      }

      if (args.dryRun && !movie) {
        movie = { id: -1 } as any;
      }

      // Create pick
      // Position 1 is the worst (isTopPosition: true)
      const isTopPosition = pick.position === 1;

      if (!args.dryRun && participant && movie) {
        try {
          await prisma.yearTopPick.upsert({
            where: {
              participantId_movieId_year_pickType: {
                participantId: participant.id,
                movieId: movie.id,
                year: args.year,
                pickType: YearTopPickType.WORST_3,
              },
            },
            create: {
              participantId: participant.id,
              movieId: movie.id,
              year: args.year,
              pickType: YearTopPickType.WORST_3,
              isTopPosition,
            },
            update: {
              isTopPosition,
            },
          });
          picksCreated++;
        } catch (error) {
          picksSkipped++;
          const errorMessage = error instanceof Error ? error.message : String(error);
          errors.push({
            participant: displayName,
            pickType: 'WORST_3',
            movieName: pick.movieName,
            error: `Failed to create pick: ${errorMessage}`,
          });
        }
      } else if (args.dryRun) {
        picksCreated++;
        console.log(
          `  Would create WORST_3 pick: ${pick.movieName} (position ${pick.position}, isTopPosition: ${isTopPosition})`
        );
      }
    }
  }

  // Print summary
  console.log('\nüìä Summary');
  console.log('==========');
  console.log(`Participants created: ${participantsCreated}`);
  console.log(`Participants updated: ${participantsUpdated}`);
  console.log(`Movies created: ${moviesCreated}`);
  console.log(`Movies skipped (already exist): ${moviesSkipped}`);
  console.log(`Picks created: ${picksCreated}`);
  console.log(`Picks skipped: ${picksSkipped}`);
  console.log(`Errors: ${errors.length}\n`);

  if (errors.length > 0) {
    console.log('‚ùå Errors:');
    for (const error of errors) {
      console.log(
        `  ${error.participant} - ${error.pickType} - ${error.movieName}: ${error.error}`
      );
    }
    console.log('');

    // Write errors to file
    const errorFile = path.join(
      path.dirname(jsonPath),
      `year-top-import-errors-${args.year}.json`
    );
    fs.writeFileSync(errorFile, JSON.stringify(errors, null, 2), 'utf8');
    console.log(`üìÑ Errors written to: ${errorFile}\n`);
  }

  if (!args.dryRun) {
    console.log('‚úÖ Import completed successfully!');
  } else {
    console.log('‚úÖ Dry run completed. Use without --dry-run to apply changes.');
  }

  await prisma.$disconnect();
}

main().catch((error) => {
  console.error('‚ùå Error:', error);
  process.exit(1);
});
